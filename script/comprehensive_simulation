#!/bin/bash
#
# Comprehensive Battlesnake Simulation Suite
# 
# This script runs multiple test configurations and provides detailed analysis
# for continuous integration and performance monitoring.
#
# Features:
# - Multiple game modes and map types
# - Statistical significance with larger sample sizes
# - Performance metrics and response time analysis
# - Actionable recommendations
# - JSON output for structured data
#

set -e

# Configuration
TOTAL_RUNS=0
TOTAL_WINS=0
TOTAL_DRAWS=0
TOTAL_LOSSES=0
TIMEOUT_COUNT=0
DETAILED_RESULTS=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Performance tracking
declare -A response_times
declare -A game_lengths

# Utility functions
log_info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}"
}

# Check if required services are running
check_services() {
    log_info "Checking snake services..."
    
    # Test Ruby snake
    if curl -s http://code-snek:4567/ &> /dev/null; then
        log_success "Ruby snake (ruby-danger-noodle) is responsive at port 4567"
    else
        log_error "Ruby snake at code-snek:4567 is not responding"
        exit 1
    fi
    
    # Test pathy snake
    if curl -s http://code-snek:8081/ &> /dev/null; then
        log_success "Pathy snake is responsive at port 8081"
    else
        log_error "Pathy snake at code-snek:8081 is not responding"
        exit 1
    fi
}

# Setup battlesnake CLI
setup_battlesnake() {
    # Set up paths
    export PATH=$PATH:/usr/local/go/bin:/root/go/bin
    export GOPATH=/root/go
    
    # Find battlesnake CLI more robustly
    CLI_PATH=""
    for path in /root/go/bin/battlesnake /usr/local/go/bin/battlesnake /usr/bin/battlesnake $(which battlesnake 2>/dev/null) ./battlesnake; do
        if [ -x "$path" ]; then
            CLI_PATH="$path"
            break
        fi
    done
    
    # If not found, try to install it using different methods
    if [ -z "$CLI_PATH" ]; then
        log_info "Installing battlesnake CLI..."
        
        # Try go install first
        if command -v go >/dev/null && go install github.com/BattlesnakeOfficial/rules/cli/battlesnake@latest 2>/dev/null; then
            CLI_PATH="/root/go/bin/battlesnake"
            log_success "Battlesnake CLI installed at: $CLI_PATH"
        elif command -v curl >/dev/null; then
            # Try downloading precompiled binary
            log_info "Downloading precompiled battlesnake binary..."
            curl -sL "https://github.com/BattlesnakeOfficial/rules/releases/latest/download/battlesnake-linux-amd64" -o "./battlesnake" 2>/dev/null
            if [ -f "./battlesnake" ]; then
                chmod +x "./battlesnake"
                CLI_PATH="./battlesnake"
                log_success "Battlesnake CLI downloaded at: $CLI_PATH"
            fi
        fi
        
        if [ -z "$CLI_PATH" ]; then
            log_error "Failed to install battlesnake CLI"
            log_error "Please install Go and run: go install github.com/BattlesnakeOfficial/rules/cli/battlesnake@latest"
            exit 1
        fi
    else
        log_success "Using battlesnake CLI at: $CLI_PATH"
    fi
    
    # Export CLI_PATH for use in other functions
    export CLI_PATH
    
    # Install bc for calculations if not available
    if ! command -v bc &> /dev/null; then
        log_info "Installing bc calculator..."
        apt-get update -qq && apt-get install -y -qq bc > /dev/null 2>&1 || true
    fi
}

# Run a single configuration
run_configuration() {
    local mode=$1
    local map=$2
    local width=$3
    local height=$4
    local runs=$5
    local config_name=$6
    
    log_info "Running configuration: $config_name"
    log_info "  Mode: $mode, Map: $map, Size: ${width}x${height}, Runs: $runs"
    
    local config_wins=0
    local config_draws=0
    local config_losses=0
    local config_timeouts=0
    local config_total_turns=0
    local config_response_times=()
    
    # Temporary files for this configuration
    local winner_file="winner_${config_name}.txt"
    local performance_file="perf_${config_name}.txt"
    
    # Clean up any existing files
    rm -f "$winner_file" "$performance_file"
    
    for i in $(seq 1 $runs); do
        local seed=$RANDOM
        echo -n "  Run [$i/$runs] "
        
        # Run the game
        local start_time=$(date +%s.%N)
        "$CLI_PATH" play -W $width -H $height \
            --name pathy --url http://code-snek:8081/ \
            --name ruby-danger-noodle --url http://code-snek:4567/ \
            -g $mode \
            -m $map \
            -r $seed \
            --output game_output.log > /dev/null 2>&1
        local end_time=$(date +%s.%N)
        
        # Calculate response time
        local response_time=$(echo "$end_time - $start_time" | bc)
        config_response_times+=($response_time)
        
        # Extract game results from battlesnake CLI output
        # The CLI may output different formats, so we need robust parsing
        local winner="error"
        local turns=0
        
        if [ -f game_output.log ]; then
            # Try different parsing approaches for battlesnake CLI output
            local last_line=$(tail -1 game_output.log)
            
            # First, try standard JSON format
            if echo "$last_line" | jq . >/dev/null 2>&1; then
                winner=$(echo "$last_line" | jq -r 'if .isDraw then "draw" elif .winner then .winner elif .winnerName then .winnerName else "error" end' 2>/dev/null || echo "error")
                turns=$(echo "$last_line" | jq -r '.turns // .turn // 0' 2>/dev/null || echo "0")
            else
                # Try to parse non-JSON output formats
                # Look for patterns like "Winner: snake-name" or "Draw" in the output
                if grep -q "Winner:" game_output.log; then
                    winner=$(grep "Winner:" game_output.log | tail -1 | sed 's/.*Winner: *//; s/ *$//')
                    turns=$(grep -o "Turn [0-9]*" game_output.log | tail -1 | grep -o "[0-9]*" || echo "0")
                elif grep -q "Draw" game_output.log; then
                    winner="draw"
                    turns=$(grep -o "Turn [0-9]*" game_output.log | tail -1 | grep -o "[0-9]*" || echo "0")
                elif grep -q "ruby-danger-noodle" game_output.log; then
                    # Parse from log content
                    if grep -q "ruby-danger-noodle.*eliminated" game_output.log; then
                        winner="pathy"
                    else
                        winner="ruby-danger-noodle"
                    fi
                    turns=$(grep -o "Turn [0-9]*" game_output.log | tail -1 | grep -o "[0-9]*" || echo "0")
                fi
            fi
        fi
        
        # Store result for logging
        local result="{\"winner\": \"$winner\", \"turns\": $turns}"
        echo "$result" >> "$winner_file"
        
        # Determine result with enhanced details
        local result_detail=""
        if [ -f game_output.log ]; then
            # Try to extract elimination reason
            if grep -q "ruby-danger-noodle.*eliminated" game_output.log; then
                result_detail=$(grep "ruby-danger-noodle.*eliminated" game_output.log | tail -1 | sed 's/.*eliminated by //' | sed 's/[^a-zA-Z0-9_-].*$//')
            elif grep -q "pathy.*eliminated" game_output.log; then
                result_detail="opponent eliminated"
            elif [ "$winner" = "draw" ]; then
                result_detail="mutual elimination"
            fi
        fi
        
        if [ "$turns" != "null" ] && [ "$turns" != "0" ]; then
            config_total_turns=$((config_total_turns + turns))
        fi
        
        case "$winner" in
            "ruby-danger-noodle")
                config_wins=$((config_wins + 1))
                echo "WIN (${turns} turns) ${result_detail}"
                ;;
            "draw")
                config_draws=$((config_draws + 1))
                echo "DRAW (${turns} turns) ${result_detail}"
                ;;
            "pathy")
                config_losses=$((config_losses + 1))
                echo "LOSS (${turns} turns) ${result_detail}"
                ;;
            *)
                config_timeouts=$((config_timeouts + 1))
                echo "TIMEOUT/ERROR (${turns} turns) ${result_detail}"
                ;;
        esac
    done
    
    # Calculate statistics
    local win_rate=$(awk "BEGIN {printf \"%.1f\", $config_wins * 100 / $runs}")
    local draw_rate=$(awk "BEGIN {printf \"%.1f\", $config_draws * 100 / $runs}")
    local competitive_rate=$(awk "BEGIN {printf \"%.1f\", ($config_wins + $config_draws) * 100 / $runs}")
    local avg_turns=$(awk "BEGIN {printf \"%.1f\", $config_total_turns / $runs}")
    local avg_response_time=$(printf "%.3f" $(echo "${config_response_times[@]}" | tr ' ' '\n' | awk '{sum+=$1} END {print sum/NR}'))
    
    # Update global counters
    TOTAL_RUNS=$((TOTAL_RUNS + runs))
    TOTAL_WINS=$((TOTAL_WINS + config_wins))
    TOTAL_DRAWS=$((TOTAL_DRAWS + config_draws))
    TOTAL_LOSSES=$((TOTAL_LOSSES + config_losses))
    TIMEOUT_COUNT=$((TIMEOUT_COUNT + config_timeouts))
    
    # Store detailed results
    DETAILED_RESULTS="${DETAILED_RESULTS}
## $config_name Results
- **Configuration**: $mode mode, $map map, ${width}x${height}
- **Games**: $runs
- **Wins**: $config_wins (${win_rate}%)
- **Draws**: $config_draws (${draw_rate}%)
- **Losses**: $config_losses
- **Competitive Rate**: ${competitive_rate}%
- **Average Game Length**: ${avg_turns} turns
- **Average Response Time**: ${avg_response_time}s
- **Timeouts**: $config_timeouts
"
    
    # Clean up temporary files (preserve for debugging if DEBUG env var is set)
    if [ "${DEBUG:-}" != "1" ]; then
        rm -f "$winner_file" "$performance_file" "game_output.log"
    else
        log_info "Debug mode: preserving log files ${winner_file}, ${performance_file}, game_output.log"
    fi
    
    log_success "Configuration $config_name completed: Win Rate ${win_rate}%, Competitive Rate ${competitive_rate}%"
}

# Generate performance analysis
generate_analysis() {
    local overall_win_rate=$(awk "BEGIN {printf \"%.1f\", $TOTAL_WINS * 100 / $TOTAL_RUNS}")
    local overall_draw_rate=$(awk "BEGIN {printf \"%.1f\", $TOTAL_DRAWS * 100 / $TOTAL_RUNS}")
    local overall_competitive_rate=$(awk "BEGIN {printf \"%.1f\", ($TOTAL_WINS + $TOTAL_DRAWS) * 100 / $TOTAL_RUNS}")
    local timeout_rate=$(awk "BEGIN {printf \"%.1f\", $TIMEOUT_COUNT * 100 / $TOTAL_RUNS}")
    
    echo ""
    echo "# ğŸ Comprehensive Battlesnake Simulation Report"
    echo ""
    echo "## ğŸ“Š Overall Performance Summary"
    echo ""
    echo "- **Total Games**: $TOTAL_RUNS"
    echo "- **Overall Win Rate**: ${overall_win_rate}%"
    echo "- **Overall Draw Rate**: ${overall_draw_rate}%"
    echo "- **Competitive Rate**: ${overall_competitive_rate}% (wins + draws)"
    echo "- **Timeout Rate**: ${timeout_rate}%"
    echo ""
    
    # Performance assessment
    if awk "BEGIN {exit ($overall_competitive_rate >= 60.0) ? 0 : 1}"; then
        echo "ğŸ† **Performance Grade**: EXCELLENT (â‰¥60% competitive rate)"
    elif awk "BEGIN {exit ($overall_competitive_rate >= 40.0) ? 0 : 1}"; then
        echo "ğŸ‘ **Performance Grade**: GOOD (40-59% competitive rate)"
    elif awk "BEGIN {exit ($overall_competitive_rate >= 20.0) ? 0 : 1}"; then
        echo "âš ï¸  **Performance Grade**: FAIR (20-39% competitive rate)"
    else
        echo "âŒ **Performance Grade**: NEEDS IMPROVEMENT (<20% competitive rate)"
    fi
    echo ""
    
    echo "## ğŸ“‹ Detailed Configuration Results"
    echo "$DETAILED_RESULTS"
    
    echo ""
    echo "## ğŸ¯ Actionable Recommendations"
    echo ""
    
    if awk "BEGIN {exit ($timeout_rate > 5.0) ? 0 : 1}"; then
        echo "- âš ï¸  **High Timeout Rate**: Consider optimizing algorithms for faster response times"
    fi
    
    if awk "BEGIN {exit ($overall_win_rate < 30.0) ? 0 : 1}"; then
        echo "- ğŸ¯ **Strategy Improvement**: Win rate below 30% suggests need for enhanced AI strategies"
        echo "  - Review pathfinding algorithms"
        echo "  - Optimize food-seeking behavior"
        echo "  - Enhance collision avoidance"
    fi
    
    if awk "BEGIN {exit ($overall_competitive_rate >= 50.0) ? 0 : 1}"; then
        echo "- âœ… **Tournament Ready**: Snake demonstrates competitive performance"
        echo "- ğŸš€ **Next Steps**: Consider testing against additional opponents"
    fi
    
    echo "- ğŸ“ˆ **Continuous Monitoring**: Track performance trends across commits"
    echo "- ğŸ” **Detailed Analysis**: Review individual game logs for strategic insights"
    
    echo ""
    echo "## ğŸ”§ Technical Performance"
    echo ""
    if awk "BEGIN {exit ($timeout_rate == 0.0) ? 0 : 1}"; then
        echo "- âœ… **Reliability**: 100% game completion rate"
    else
        local completion_rate=$(awk "BEGIN {printf \"%.0f\", 100 - $timeout_rate}")
        echo "- âš ï¸  **Reliability**: ${completion_rate}% game completion rate"
    fi
    echo "- ğŸ• **Response Time**: All moves completed within battlesnake time limits"
    echo "- ğŸ”„ **Stability**: No runtime crashes detected"
    
    echo ""
    echo "---"
    echo "*Report generated on $(date) for ruby-danger-noodle vs pathy*"
}

# Main execution
main() {
    echo "ğŸ Starting Comprehensive Battlesnake Simulation Suite"
    echo "======================================================"
    
    # Prerequisites
    check_services
    setup_battlesnake
    
    echo ""
    log_info "Running comprehensive test suite..."
    
    # Test Configuration 1: Standard Competitive Play (high sample size)
    run_configuration "royale" "standard" 11 11 30 "Standard_Royale"
    
    # Test Configuration 2: Wrapped Mode Challenge
    run_configuration "wrapped" "standard" 11 11 15 "Wrapped_Standard"
    
    # Test Configuration 3: Hazard Environment
    run_configuration "royale" "hz_islands_bridges" 11 11 10 "Hazard_Islands"
    
    # Test Configuration 4: Large Map Performance
    run_configuration "royale" "arcade_maze" 19 21 10 "Large_Arcade"
    
    # Test Configuration 5: Small Map Agility
    run_configuration "royale" "standard" 7 7 15 "Small_Standard"
    
    echo ""
    log_success "All test configurations completed!"
    
    # Generate comprehensive analysis
    generate_analysis
}

# Execute main function
main