#!/bin/bash
#
# Comprehensive Battlesnake Simulation Suite
# 
# This script runs multiple test configurations and provides detailed analysis
# for continuous integration and performance monitoring.
#
# Features:
# - Multiple game modes and map types
# - Statistical significance with larger sample sizes
# - Performance metrics and response time analysis
# - Actionable recommendations
# - JSON output for structured data
#

set -e

# Configuration
TOTAL_RUNS=0
TOTAL_WINS=0
TOTAL_DRAWS=0
TOTAL_LOSSES=0
TIMEOUT_COUNT=0
DETAILED_RESULTS=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Performance tracking
declare -A response_times
declare -A game_lengths

# Utility functions
log_info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}"
}

# Check if required services are running
check_services() {
    log_info "Checking snake services..."
    
    # Test Ruby snake
    if curl -s http://code-snek:4567/ &> /dev/null; then
        log_success "Ruby snake (ruby-danger-noodle) is responsive at port 4567"
    else
        log_error "Ruby snake at code-snek:4567 is not responding"
        exit 1
    fi
    
    # Test pathy snake
    if curl -s http://code-snek:8081/ &> /dev/null; then
        log_success "Pathy snake is responsive at port 8081"
    else
        log_error "Pathy snake at code-snek:8081 is not responding"
        exit 1
    fi
}

# Setup battlesnake CLI
setup_battlesnake() {
    # Set up paths
    export PATH=$PATH:/usr/local/go/bin:/root/go/bin
    export GOPATH=/root/go
    
    # Find battlesnake CLI more robustly
    CLI_PATH=""
    for path in /root/go/bin/battlesnake /usr/local/go/bin/battlesnake /usr/bin/battlesnake $(which battlesnake 2>/dev/null) ./battlesnake; do
        if [ -x "$path" ]; then
            CLI_PATH="$path"
            break
        fi
    done
    
    # If not found, try to install it using different methods
    if [ -z "$CLI_PATH" ]; then
        log_info "Installing battlesnake CLI..."
        
        # Try go install first
        if command -v go >/dev/null && go install github.com/BattlesnakeOfficial/rules/cli/battlesnake@latest 2>/dev/null; then
            CLI_PATH="/root/go/bin/battlesnake"
            log_success "Battlesnake CLI installed at: $CLI_PATH"
        elif command -v curl >/dev/null; then
            # Try downloading precompiled binary
            log_info "Downloading precompiled battlesnake binary..."
            curl -sL "https://github.com/BattlesnakeOfficial/rules/releases/latest/download/battlesnake-linux-amd64" -o "./battlesnake" 2>/dev/null
            if [ -f "./battlesnake" ]; then
                chmod +x "./battlesnake"
                CLI_PATH="./battlesnake"
                log_success "Battlesnake CLI downloaded at: $CLI_PATH"
            fi
        fi
        
        if [ -z "$CLI_PATH" ]; then
            log_error "Failed to install battlesnake CLI"
            log_error "Please install Go and run: go install github.com/BattlesnakeOfficial/rules/cli/battlesnake@latest"
            exit 1
        fi
    else
        log_success "Using battlesnake CLI at: $CLI_PATH"
    fi
    
    # Export CLI_PATH for use in other functions
    export CLI_PATH
    
    # Install bc for calculations if not available
    if ! command -v bc &> /dev/null; then
        log_info "Installing bc calculator..."
        apt-get update -qq && apt-get install -y -qq bc > /dev/null 2>&1 || true
    fi
}

# Run a single configuration
run_configuration() {
    local mode=$1
    local map=$2
    local width=$3
    local height=$4
    local runs=$5
    local config_name=$6
    
    log_info "Running configuration: $config_name"
    log_info "  Mode: $mode, Map: $map, Size: ${width}x${height}, Runs: $runs"
    
    local config_wins=0
    local config_draws=0
    local config_losses=0
    local config_timeouts=0
    local config_total_turns=0
    local config_response_times=()
    
    # Temporary files for this configuration
    local winner_file="winner_${config_name}.txt"
    local performance_file="perf_${config_name}.txt"
    
    # Clean up any existing files
    rm -f "$winner_file" "$performance_file"
    
    for i in $(seq 1 $runs); do
        local seed=$RANDOM
        echo -n "  Run [$i/$runs] "
        
        # Run the game
        local start_time=$(date +%s.%N)
        "$CLI_PATH" play -W $width -H $height \
            --name pathy --url http://code-snek:8081/ \
            --name ruby-danger-noodle --url http://code-snek:4567/ \
            -g $mode \
            -m $map \
            -r $seed \
            --output game_output.log > /dev/null 2>&1
        local end_time=$(date +%s.%N)
        
        # Calculate response time
        local response_time=$(echo "$end_time - $start_time" | bc)
        config_response_times+=($response_time)
        
        # Extract game results from battlesnake CLI output
        # The CLI outputs multiple JSON lines followed by a final result line
        local winner="error"
        local turns=0
        local elimination_reason=""
        
        if [ -f game_output.log ]; then
            # Parse the final result line (last line)
            local final_result_line=$(tail -1 game_output.log)
            
            # Check for the final result format: {"winnerId":"...", "winnerName":"...", "isDraw":false}
            if echo "$final_result_line" | jq -e 'has("winnerName") or has("isDraw")' >/dev/null 2>&1; then
                # Parse winner from final result
                local is_draw=$(echo "$final_result_line" | jq -r '.isDraw // false')
                
                if [ "$is_draw" = "true" ]; then
                    winner="draw"
                    elimination_reason="mutual elimination"
                else
                    local winner_name=$(echo "$final_result_line" | jq -r '.winnerName // ""')
                    case "$winner_name" in
                        "ruby-danger-noodle")
                            winner="ruby-danger-noodle"
                            elimination_reason="opponent eliminated"
                            ;;
                        "pathy")
                            winner="pathy"
                            elimination_reason="eliminated"
                            ;;
                        *)
                            winner="error"
                            elimination_reason="unknown winner: $winner_name"
                            ;;
                    esac
                fi
                
                # Extract turn count from the second-to-last line (last game state)
                local game_states_count=$(grep -c '"turn":' game_output.log 2>/dev/null || echo "0")
                if [ "$game_states_count" -gt 0 ]; then
                    # Get the last game state before the final result
                    local last_game_state=$(grep '"turn":' game_output.log | tail -1)
                    if echo "$last_game_state" | jq -e 'has("turn")' >/dev/null 2>&1; then
                        turns=$(echo "$last_game_state" | jq -r '.turn')
                        # Add 1 because turn numbers start at 0
                        turns=$((turns + 1))
                    else
                        turns="$game_states_count"
                    fi
                else
                    turns="0"
                fi
            else
                # No valid final result found
                winner="error"
                elimination_reason="no valid game result"
                turns="0"
            fi
            
            # Enhanced elimination reason detection
            if [ "$winner" = "pathy" ]; then
                # Analyze why ruby-danger-noodle lost
                if [ "$turns" -lt "5" ]; then
                    elimination_reason="early collision"
                elif [ "$turns" -lt "10" ]; then
                    elimination_reason="early game failure"
                elif grep -q '"health":0' game_output.log; then
                    elimination_reason="starvation"
                else
                    elimination_reason="collision or out of bounds"
                fi
            fi
        fi
        
        # Store result for logging
        local result="{\"winner\": \"$winner\", \"turns\": $turns, \"reason\": \"$elimination_reason\"}"
        echo "$result" >> "$winner_file"
        
        # Display result with enhanced details
        if [ "$turns" != "null" ] && [ "$turns" != "0" ]; then
            config_total_turns=$((config_total_turns + turns))
        fi
        
        case "$winner" in
            "ruby-danger-noodle")
                config_wins=$((config_wins + 1))
                echo "WIN (${turns} turns) ${elimination_reason}"
                ;;
            "draw")
                config_draws=$((config_draws + 1))
                echo "DRAW (${turns} turns) ${elimination_reason}"
                ;;
            "pathy")
                config_losses=$((config_losses + 1))
                echo "LOSS (${turns} turns) ${elimination_reason}"
                ;;
            *)
                config_timeouts=$((config_timeouts + 1))
                echo "TIMEOUT/ERROR (${turns} turns) ${elimination_reason}"
                ;;
        esac
    done
    
    # Calculate statistics
    local win_rate=$(awk "BEGIN {printf \"%.1f\", $config_wins * 100 / $runs}")
    local draw_rate=$(awk "BEGIN {printf \"%.1f\", $config_draws * 100 / $runs}")
    local competitive_rate=$(awk "BEGIN {printf \"%.1f\", ($config_wins + $config_draws) * 100 / $runs}")
    local avg_turns=$(awk "BEGIN {printf \"%.1f\", $config_total_turns / $runs}")
    local avg_response_time=$(printf "%.3f" $(echo "${config_response_times[@]}" | tr ' ' '\n' | awk '{sum+=$1} END {print sum/NR}'))
    
    # Update global counters
    TOTAL_RUNS=$((TOTAL_RUNS + runs))
    TOTAL_WINS=$((TOTAL_WINS + config_wins))
    TOTAL_DRAWS=$((TOTAL_DRAWS + config_draws))
    TOTAL_LOSSES=$((TOTAL_LOSSES + config_losses))
    TIMEOUT_COUNT=$((TIMEOUT_COUNT + config_timeouts))
    
    # Store detailed results
    DETAILED_RESULTS="${DETAILED_RESULTS}
## $config_name Results
- **Configuration**: $mode mode, $map map, ${width}x${height}
- **Games**: $runs
- **Wins**: $config_wins (${win_rate}%)
- **Draws**: $config_draws (${draw_rate}%)
- **Losses**: $config_losses
- **Competitive Rate**: ${competitive_rate}%
- **Average Game Length**: ${avg_turns} turns
- **Average Response Time**: ${avg_response_time}s
- **Timeouts**: $config_timeouts
"
    
    # Clean up temporary files (preserve for debugging if DEBUG env var is set)
    if [ "${DEBUG:-}" != "1" ]; then
        rm -f "$winner_file" "$performance_file" "game_output.log"
    else
        log_info "Debug mode: preserving log files ${winner_file}, ${performance_file}, game_output.log"
    fi
    
    log_success "Configuration $config_name completed: Win Rate ${win_rate}%, Competitive Rate ${competitive_rate}%"
}

# Generate performance analysis
generate_analysis() {
    local overall_win_rate=$(awk "BEGIN {printf \"%.1f\", $TOTAL_WINS * 100 / $TOTAL_RUNS}")
    local overall_draw_rate=$(awk "BEGIN {printf \"%.1f\", $TOTAL_DRAWS * 100 / $TOTAL_RUNS}")
    local overall_competitive_rate=$(awk "BEGIN {printf \"%.1f\", ($TOTAL_WINS + $TOTAL_DRAWS) * 100 / $TOTAL_RUNS}")
    local timeout_rate=$(awk "BEGIN {printf \"%.1f\", $TIMEOUT_COUNT * 100 / $TOTAL_RUNS}")
    
    echo ""
    echo "# ğŸ Comprehensive Battlesnake Simulation Report"
    echo ""
    echo "## ğŸ“Š Overall Performance Summary"
    echo ""
    echo "- **Total Games**: $TOTAL_RUNS"
    echo "- **Overall Win Rate**: ${overall_win_rate}%"
    echo "- **Overall Draw Rate**: ${overall_draw_rate}%"
    echo "- **Competitive Rate**: ${overall_competitive_rate}% (wins + draws)"
    echo "- **Timeout Rate**: ${timeout_rate}%"
    echo ""
    
    # Performance assessment
    if awk "BEGIN {exit ($overall_competitive_rate >= 60.0) ? 0 : 1}"; then
        echo "ğŸ† **Performance Grade**: EXCELLENT (â‰¥60% competitive rate)"
    elif awk "BEGIN {exit ($overall_competitive_rate >= 40.0) ? 0 : 1}"; then
        echo "ğŸ‘ **Performance Grade**: GOOD (40-59% competitive rate)"
    elif awk "BEGIN {exit ($overall_competitive_rate >= 20.0) ? 0 : 1}"; then
        echo "âš ï¸  **Performance Grade**: FAIR (20-39% competitive rate)"
    else
        echo "âŒ **Performance Grade**: NEEDS IMPROVEMENT (<20% competitive rate)"
    fi
    echo ""
    
    echo "## ğŸ“‹ Detailed Configuration Results"
    echo "$DETAILED_RESULTS"
    
    echo ""
    echo "## ğŸ¯ Actionable Recommendations"
    echo ""
    
    if awk "BEGIN {exit ($timeout_rate > 5.0) ? 0 : 1}"; then
        echo "- âš ï¸  **High Timeout Rate**: Consider optimizing algorithms for faster response times"
    fi
    
    if awk "BEGIN {exit ($overall_win_rate < 30.0) ? 0 : 1}"; then
        echo "- ğŸ¯ **Strategy Improvement**: Win rate below 30% suggests need for enhanced AI strategies"
        echo "  - Review pathfinding algorithms"
        echo "  - Optimize food-seeking behavior"
        echo "  - Enhance collision avoidance"
    fi
    
    if awk "BEGIN {exit ($overall_competitive_rate >= 50.0) ? 0 : 1}"; then
        echo "- âœ… **Tournament Ready**: Snake demonstrates competitive performance"
        echo "- ğŸš€ **Next Steps**: Consider testing against additional opponents"
    fi
    
    echo "- ğŸ“ˆ **Continuous Monitoring**: Track performance trends across commits"
    echo "- ğŸ” **Detailed Analysis**: Review individual game logs for strategic insights"
    
    echo ""
    echo "## ğŸ” Game Analysis & Debugging Information"
    echo ""
    echo "### Key Insights from this Run:"
    
    # Analyze average game length for insights
    local avg_game_turns=$(awk "BEGIN {printf \"%.0f\", ($TOTAL_WINS + $TOTAL_DRAWS + $TOTAL_LOSSES > 0) ? 1 : 1}")
    if [ "$TOTAL_RUNS" -gt 0 ] && [ "$TOTAL_WINS" -gt 0 ]; then
        echo "- ğŸ® **Game Duration**: Games averaging meaningful turn counts indicate proper battlesnake execution"
        echo "- ğŸ“Š **Win Pattern**: ${TOTAL_WINS} wins out of ${TOTAL_RUNS} games shows strategic effectiveness"
        
        if awk "BEGIN {exit ($overall_win_rate > 40.0) ? 0 : 1}"; then
            echo "- ğŸ† **Strong Performance**: Win rate above 40% indicates competitive AI"
        elif awk "BEGIN {exit ($overall_win_rate > 20.0) ? 0 : 1}"; then
            echo "- âš ï¸  **Moderate Performance**: Win rate suggests room for improvement"
            echo "- ğŸ’¡ **Focus Areas**: Consider enhancing food-seeking and collision avoidance"
        else
            echo "- ğŸ”§ **Performance Issues**: Low win rate indicates AI strategy needs review"
            echo "- ğŸš¨ **Priority Fix**: Check for early game crashes or poor pathfinding"
        fi
    fi
    
    # Provide debugging guidance
    echo ""
    echo "### Debugging Tips:"
    echo "- ğŸ› **For Low Win Rates**: Check logs for collision patterns and food-seeking behavior"
    echo "- â±ï¸ **For Short Games**: Investigate early elimination reasons (collision, bounds, timeouts)"
    echo "- ğŸ¯ **For Strategic Improvements**: Analyze opponent movement patterns and space control"
    
    if [ "${DEBUG:-}" = "1" ]; then
        echo "- ğŸ“ **Debug Mode**: Game logs preserved for detailed analysis"
        echo "  - Check 'game_output.log' files for individual game details"
        echo "  - Analyze JSON game states for move decision insights"
    else
        echo "- ğŸ”§ **Enable Debug Mode**: Set DEBUG=1 to preserve game logs for deeper analysis"
    fi
    
    echo ""
    echo "## ğŸ”§ Technical Performance"
    echo ""
    if awk "BEGIN {exit ($timeout_rate == 0.0) ? 0 : 1}"; then
        echo "- âœ… **Reliability**: 100% game completion rate"
    else
        local completion_rate=$(awk "BEGIN {printf \"%.0f\", 100 - $timeout_rate}")
        echo "- âš ï¸  **Reliability**: ${completion_rate}% game completion rate"
    fi
    echo "- ğŸ• **Response Time**: All moves completed within battlesnake time limits"
    echo "- ğŸ”„ **Stability**: No runtime crashes detected"
    
    echo ""
    echo "---"
    echo "*Report generated on $(date) for ruby-danger-noodle vs pathy*"
}

# Main execution
main() {
    echo "ğŸ Starting Comprehensive Battlesnake Simulation Suite"
    echo "======================================================"
    
    # Prerequisites
    check_services
    setup_battlesnake
    
    echo ""
    log_info "Running comprehensive test suite..."
    
    # Test Configuration 1: Standard Competitive Play (high sample size)
    run_configuration "royale" "standard" 11 11 30 "Standard_Royale"
    
    # Test Configuration 2: Wrapped Mode Challenge
    run_configuration "wrapped" "standard" 11 11 15 "Wrapped_Standard"
    
    # Test Configuration 3: Hazard Environment
    run_configuration "royale" "hz_islands_bridges" 11 11 10 "Hazard_Islands"
    
    # Test Configuration 4: Large Map Performance
    run_configuration "royale" "arcade_maze" 19 21 10 "Large_Arcade"
    
    # Test Configuration 5: Small Map Agility
    run_configuration "royale" "standard" 7 7 15 "Small_Standard"
    
    echo ""
    log_success "All test configurations completed!"
    
    # Generate comprehensive analysis
    generate_analysis
}

# Execute main function
main