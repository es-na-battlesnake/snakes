#!/bin/bash
#
# Simulation Infrastructure Validation
# 
# This script validates that the simulation infrastructure is working correctly
# before running the comprehensive tests.
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; }

# Test battlesnake CLI installation
test_battlesnake_cli() {
    log_info "Testing battlesnake CLI installation..."
    
    # Set up Go paths
    export PATH=$PATH:/usr/local/go/bin:/root/go/bin
    export GOPATH=/root/go
    
    # Check if CLI exists in common locations
    CLI_PATH=""
    for path in /root/go/bin/battlesnake /usr/local/go/bin/battlesnake $(which battlesnake 2>/dev/null); do
        if [ -x "$path" ]; then
            CLI_PATH="$path"
            break
        fi
    done
    
    # If not found, try to install it
    if [ -z "$CLI_PATH" ]; then
        log_info "Battlesnake CLI not found, attempting installation..."
        if go install github.com/BattlesnakeOfficial/rules/cli/battlesnake@latest 2>/dev/null; then
            CLI_PATH="/root/go/bin/battlesnake"
        else
            log_warning "Unable to install battlesnake CLI, skipping CLI-dependent tests"
            return 0  # Don't fail validation if CLI can't be installed
        fi
    fi
    
    # Test the CLI
    if [ -n "$CLI_PATH" ] && "$CLI_PATH" --version > /dev/null 2>&1; then
        log_success "Battlesnake CLI is installed and functional: $CLI_PATH"
        export BATTLESNAKE_CLI="$CLI_PATH"
    else
        log_warning "Battlesnake CLI not functional, skipping CLI-dependent tests"
        export BATTLESNAKE_CLI=""
        return 0  # Don't fail validation
    fi
}

# Test snake service endpoints
test_snake_endpoints() {
    log_info "Testing snake service endpoints..."
    
    # Enhanced context detection for Docker networks
    local BASE_URL=""
    local connection_successful=false
    
    # Method 1: Try code-snek hostname (Docker network)
    log_info "Testing Docker network connectivity to code-snek..."
    if timeout 10 bash -c "for i in {1..3}; do curl -s --connect-timeout 3 --max-time 5 'http://code-snek:4567/' >/dev/null 2>&1 && exit 0; sleep 2; done; exit 1"; then
        BASE_URL="http://code-snek"
        connection_successful=true
        log_success "Docker network connectivity confirmed - using code-snek hostname"
    else
        log_warning "code-snek hostname not responding, trying localhost fallback..."
        
        # Method 2: Try localhost fallback
        if timeout 10 bash -c "for i in {1..3}; do curl -s --connect-timeout 3 --max-time 5 'http://localhost:4567/' >/dev/null 2>&1 && exit 0; sleep 2; done; exit 1"; then
            BASE_URL="http://localhost"
            connection_successful=true
            log_success "Localhost connectivity confirmed - using localhost"
        else
            log_error "Neither code-snek nor localhost responding on port 4567"
            log_info "This suggests the Ruby snake service is not running or not accessible"
            return 1
        fi
    fi
    
    log_info "Using base URL: $BASE_URL"
    
    # Test Ruby snake endpoint with robust error handling
    log_info "Testing Ruby snake endpoint at ${BASE_URL}:4567..."
    local ruby_response=""
    local ruby_success=false
    
    for attempt in 1 2 3; do
        ruby_response=$(timeout 8 curl -s --connect-timeout 3 --max-time 6 "${BASE_URL}:4567/" 2>/dev/null || echo "")
        
        if [ -n "$ruby_response" ]; then
            # Check if response is valid JSON
            if echo "$ruby_response" | jq . > /dev/null 2>&1; then
                local ruby_name=$(echo "$ruby_response" | jq -r '.name // "unknown"' 2>/dev/null)
                log_success "Ruby snake endpoint responsive: $ruby_name"
                ruby_success=true
                break
            elif echo "$ruby_response" | grep -qi "name\|snake" && echo "$ruby_response" | grep -q "{"; then
                # Fallback for malformed JSON that still contains snake info
                local ruby_name=$(echo "$ruby_response" | grep -o '"name":"[^"]*"' | cut -d'"' -f4 2>/dev/null || echo "unknown")
                log_success "Ruby snake endpoint responsive: $ruby_name"
                ruby_success=true
                break
            fi
        fi
        
        if [ $attempt -lt 3 ]; then
            log_info "Retrying Ruby snake connection (attempt $((attempt + 1))/3)..."
            sleep 2
        fi
    done
    
    if [ "$ruby_success" != "true" ]; then
        log_error "Ruby snake endpoint not responding with valid JSON after 3 attempts"
        log_info "Response: $(echo "$ruby_response" | head -c 200)"
        return 1
    fi
    
    # Test pathy snake endpoint with robust error handling
    log_info "Testing Pathy snake endpoint at ${BASE_URL}:8081..."
    local pathy_response=""
    local pathy_success=false
    
    for attempt in 1 2 3; do
        pathy_response=$(timeout 8 curl -s --connect-timeout 3 --max-time 6 "${BASE_URL}:8081/" 2>/dev/null || echo "")
        
        if [ -n "$pathy_response" ]; then
            # Check if response is valid JSON
            if echo "$pathy_response" | jq . > /dev/null 2>&1; then
                local pathy_name=$(echo "$pathy_response" | jq -r '.name // "unknown"' 2>/dev/null)
                log_success "Pathy snake endpoint responsive: $pathy_name"
                pathy_success=true
                break
            elif echo "$pathy_response" | grep -qi "name\|snake" && echo "$pathy_response" | grep -q "{"; then
                # Fallback for malformed JSON
                local pathy_name=$(echo "$pathy_response" | grep -o '"name":"[^"]*"' | cut -d'"' -f4 2>/dev/null || echo "unknown")
                log_success "Pathy snake endpoint responsive: $pathy_name"
                pathy_success=true
                break
            fi
        fi
        
        if [ $attempt -lt 3 ]; then
            log_info "Retrying Pathy snake connection (attempt $((attempt + 1))/3)..."
            sleep 2
        fi
    done
    
    if [ "$pathy_success" != "true" ]; then
        log_error "Pathy snake endpoint not responding with valid JSON after 3 attempts"
        log_info "Response: $(echo "$pathy_response" | head -c 200)"
        return 1
    fi
}

# Test move endpoints
test_move_endpoints() {
    log_info "Testing snake move endpoints..."
    
    # Reuse the BASE_URL from test_snake_endpoints
    local BASE_URL="http://code-snek"
    
    # Test connectivity again to determine correct base URL
    if ! timeout 5 bash -c "curl -s --connect-timeout 2 --max-time 4 '${BASE_URL}:4567/' >/dev/null 2>&1"; then
        BASE_URL="http://localhost"
    fi
    
    # Create a simple test game state
    local test_game_state='{
        "game": {"id": "test", "ruleset": {"name": "standard"}, "timeout": 500},
        "turn": 1,
        "board": {
            "height": 11,
            "width": 11,
            "food": [{"x": 5, "y": 5}],
            "hazards": [],
            "snakes": [
                {
                    "id": "ruby-test",
                    "name": "ruby-danger-noodle",
                    "health": 100,
                    "body": [{"x": 1, "y": 1}, {"x": 1, "y": 2}],
                    "head": {"x": 1, "y": 1}
                }
            ]
        },
        "you": {
            "id": "ruby-test",
            "name": "ruby-danger-noodle", 
            "health": 100,
            "body": [{"x": 1, "y": 1}, {"x": 1, "y": 2}],
            "head": {"x": 1, "y": 1}
        }
    }'
    
    # Test Ruby snake move endpoint
    local ruby_move=$(curl -s -X POST -H "Content-Type: application/json" \
        -d "$test_game_state" "${BASE_URL}:4567/move" 2>/dev/null || echo "")
    
    if echo "$ruby_move" | jq . > /dev/null 2>&1; then
        local move=$(echo "$ruby_move" | jq -r '.move // "unknown"')
        if [[ "$move" =~ ^(up|down|left|right)$ ]]; then
            log_success "Ruby snake move endpoint functional: $move"
        else
            log_warning "Ruby snake returned unexpected move: $move"
        fi
    else
        log_error "Ruby snake move endpoint not responding with valid JSON"
        log_info "Response: $ruby_move"
        return 1
    fi
    
    # Test pathy snake move endpoint
    local pathy_move=$(curl -s -X POST -H "Content-Type: application/json" \
        -d "$test_game_state" "${BASE_URL}:8081/move" 2>/dev/null || echo "")
    
    if echo "$pathy_move" | jq . > /dev/null 2>&1; then
        local move=$(echo "$pathy_move" | jq -r '.move // "unknown"')
        if [[ "$move" =~ ^(up|down|left|right)$ ]]; then
            log_success "Pathy snake move endpoint functional: $move"
        else
            log_warning "Pathy snake returned unexpected move: $move"
        fi
    else
        log_error "Pathy snake move endpoint not responding with valid JSON"
        log_info "Response: $pathy_move"
        return 1
    fi
}

# Test single game simulation
test_single_game() {
    log_info "Testing single game simulation..."
    
    # Skip if CLI not available
    if [ -z "$BATTLESNAKE_CLI" ]; then
        log_warning "Skipping single game test - CLI not available"
        return 0
    fi
    
    # Determine base URL (same logic as other functions)
    local BASE_URL="http://code-snek"
    if ! timeout 5 bash -c "curl -s --connect-timeout 2 --max-time 4 '${BASE_URL}:4567/' >/dev/null 2>&1"; then
        BASE_URL="http://localhost"
    fi
    
    local game_output=$("$BATTLESNAKE_CLI" play -W 11 -H 11 \
        --name pathy --url "${BASE_URL}:8081/" \
        --name ruby-danger-noodle --url "${BASE_URL}:4567/" \
        -g royale -m standard --output /dev/stdout 2>/dev/null || echo "")
    
    if echo "$game_output" | jq . > /dev/null 2>&1; then
        local winner=$(echo "$game_output" | jq -r '.winnerName // .isDraw // "unknown"')
        local turns=$(echo "$game_output" | jq -r '.turns // 0')
        
        if [ "$turns" -gt 0 ]; then
            log_success "Single game simulation successful: $winner in $turns turns"
        else
            log_warning "Game completed but with 0 turns recorded"
        fi
    else
        log_error "Single game simulation failed or returned invalid output"
        log_info "Output: $(echo "$game_output" | head -3)"
        return 1
    fi
}

# Test performance metrics
test_performance_metrics() {
    log_info "Testing performance metrics collection..."
    
    # Skip if CLI not available
    if [ -z "$BATTLESNAKE_CLI" ]; then
        log_warning "Skipping performance metrics test - CLI not available"
        return 0
    fi
    
    # Determine base URL (same logic as other functions)
    local BASE_URL="http://code-snek"
    if ! timeout 5 bash -c "curl -s --connect-timeout 2 --max-time 4 '${BASE_URL}:4567/' >/dev/null 2>&1"; then
        BASE_URL="http://localhost"
    fi
    
    local start_time=$(date +%s.%N)
    
    # Run a quick single game for timing
    "$BATTLESNAKE_CLI" play -W 7 -H 7 \
        --name pathy --url "${BASE_URL}:8081/" \
        --name ruby-danger-noodle --url "${BASE_URL}:4567/" \
        -g royale -m standard --output /dev/null 2>/dev/null || true
    
    local end_time=$(date +%s.%N)
    
    # Calculate duration (fallback to integer arithmetic if bc not available)
    if command -v bc &> /dev/null; then
        local duration=$(echo "$end_time - $start_time" | bc)
        if (( $(echo "$duration < 30.0" | bc -l) )); then
            log_success "Performance metrics: Single game completed in ${duration}s"
        else
            log_warning "Performance metrics: Single game took ${duration}s (may be slow)"
        fi
    else
        # Fallback integer calculation
        local start_int=${start_time%.*}
        local end_int=${end_time%.*}
        local duration=$((end_int - start_int))
        
        if [ "$duration" -lt 30 ]; then
            log_success "Performance metrics: Single game completed in ~${duration}s"
        else
            log_warning "Performance metrics: Single game took ~${duration}s (may be slow)"
        fi
    fi
}

# Main validation function
main() {
    echo "🧪 Battlesnake Simulation Infrastructure Validation"
    echo "=================================================="
    echo ""
    
    local failures=0
    
    # Run all validation tests (allow some to fail gracefully)
    test_battlesnake_cli || log_warning "CLI test had issues but continuing..."
    echo ""
    
    test_snake_endpoints || ((failures++))
    echo ""
    
    test_move_endpoints || ((failures++))
    echo ""
    
    # These are nice-to-have tests that shouldn't block the workflow
    if [ -n "$BATTLESNAKE_CLI" ]; then
        test_single_game || log_warning "Single game test failed but continuing..."
        echo ""
        
        test_performance_metrics || log_warning "Performance metrics test failed but continuing..."
        echo ""
    fi
    
    # Summary
    if [ $failures -eq 0 ]; then
        log_success "All critical validation tests passed! ✨"
        log_info "Simulation infrastructure is ready for comprehensive testing"
        return 0
    elif [ $failures -le 1 ]; then
        log_warning "$failures non-critical validation test(s) failed"
        log_info "Simulation infrastructure should still work for basic testing"
        return 0
    else
        log_error "$failures critical validation test(s) failed"
        log_info "Please fix the critical issues before running comprehensive simulations"
        return 1
    fi
}

# Execute if called directly
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
    main "$@"
fi